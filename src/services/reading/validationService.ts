
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { ValidateReadingRequest, ValidateReadingResponse } from "@/types/reading";
import { getQuestionForBookSegment } from "../questionService";
import { recordReadingActivity } from "../streakService";
import { getBookReadingProgress, clearProgressCache } from "./progressService";
import { Badge } from "@/types/badge";
import { checkBadgesForUser } from "@/services/user/streakBadgeService";
import { checkUserQuests } from "@/services/questService";
import { addXP } from "@/services/user/levelService";
import { checkAndGrantMonthlyReward } from "@/services/monthlyRewardService";
import { Database } from "@/integrations/supabase/types";
import { mutate } from 'swr';

type ReadingValidationRecord = Database['public']['Tables']['reading_validations']['Insert'];

/**
 * Valide un segment de lecture
 * @param request Requ√™te de validation
 * @returns R√©ponse de validation avec potentiellement des badges
 */
export const validateReading = async (
  request: ValidateReadingRequest
): Promise<ValidateReadingResponse & { newBadges?: Badge[] }> => {
  try {
    console.log('üîç D√©but de validateReading pour segment:', request.segment);

    // V√©rifier si le segment est d√©j√† valid√©
    const progress = await getBookReadingProgress(request.user_id, request.book_id);
    
    // R√©cup√©rer les informations du livre pour conna√Ætre total_pages
    const { data: bookData, error: bookError } = await supabase
      .from('books')
      .select('total_pages')
      .eq('id', request.book_id)
      .single();
    
    if (bookError) {
      console.error('Error fetching book:', bookError);
      throw new Error("‚ùå Impossible de r√©cup√©rer les informations du livre");
    }
    
    const totalPages = bookData?.total_pages || 0;
    const newCurrentPage = (request.segment + 1) * 8000;
    
    // D√©terminer si le livre sera compl√©t√© apr√®s cette validation
    const newStatus = newCurrentPage >= totalPages ? 'completed' : 'in_progress';
    
    let progressId: string;
    
    if (!progress) {
      console.log('üìö Aucune progression existante, cr√©ation d\'une nouvelle entr√©e');
      
      // Cr√©er une nouvelle entr√©e de progression si elle n'existe pas
      const { data: newProgress, error: insertError } = await supabase
        .from('reading_progress')
        .insert({
          user_id: request.user_id,
          book_id: request.book_id,
          current_page: newCurrentPage,
          total_pages: totalPages,
          status: newStatus,
          started_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();
      
      if (insertError) {
        console.error('Error creating reading progress:', insertError);
        toast.error("√âchec de cr√©ation de la progression de lecture");
        throw insertError;
      }
      
      progressId = newProgress.id;
      console.log("‚úÖ Nouvelle progression cr√©√©e avec ID:", progressId);
    } else {
      // Utiliser la progression existante et la mettre √† jour si n√©cessaire
      progressId = progress.id;
      
      // Ne mettre √† jour current_page que si la nouvelle valeur est sup√©rieure
      const updatedCurrentPage = Math.max(newCurrentPage, progress.current_page || 0);
      
      // V√©rifier si le segment est d√©j√† valid√©
      if (request.segment <= progress.chaptersRead) {
        console.log('üìù Segment already validated:', request.segment, 'chaptersRead:', progress.chaptersRead);
        
        return {
          message: "Segment d√©j√† valid√©",
          current_page: progress.current_page,
          already_validated: true,
          next_segment_question: null
        };
      }
      
      const { error: progressError } = await supabase
        .from('reading_progress')
        .update({
          current_page: updatedCurrentPage,
          status: newStatus,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', request.user_id)
        .eq('book_id', request.book_id);

      if (progressError) {
        console.error('Error updating reading progress:', progressError);
        toast.error("√âchec de mise √† jour dans Supabase");
        throw progressError;
      }
      
      console.log("‚úÖ Progression mise √† jour, ID:", progressId);
    }

    const question = await getQuestionForBookSegment(request.book_id, request.segment);
    console.log("üìö Question r√©cup√©r√©e :", question);

    const validationRecord: ReadingValidationRecord = {
      user_id: request.user_id,
      book_id: request.book_id,
      segment: request.segment,
      question_id: question?.id ?? null,
      correct: true,
      validated_at: new Date().toISOString(),
      answer: question?.answer ?? undefined,
      progress_id: progressId  // Utiliser l'ID de progression obtenu
    };

    console.log("üßæ Enregistrement validation :", validationRecord);

    const { error: validationError } = await supabase
      .from('reading_validations')
      .insert(validationRecord);

    if (validationError) {
      console.error('Error inserting validation record:', validationError);
      toast.error("√âchec d'enregistrement de la validation dans Supabase");
      throw validationError;
    }
    
    console.log("‚úÖ Supabase insert success - reading_validations");

    await clearProgressCache(request.user_id);
    console.log(`‚úÖ Cache vid√© pour l'utilisateur ${request.user_id} apr√®s validation d'un segment`);

    // Mutation SWR - force refresh des donn√©es pour SWR
    mutate((key) => typeof key === 'string' && key.includes(`reading-progress-${request.user_id}`), undefined, true);
    // Mutation alternative si la premi√®re ne fonctionne pas
    mutate(() => getBookReadingProgress(request.user_id, request.book_id));
    
    console.log("‚úÖ SWR cache mutation triggered");

    await recordReadingActivity(request.user_id);
    await addXP(request.user_id, 10);

    const nextSegment = request.segment + 1;
    const nextQuestion = await getQuestionForBookSegment(request.book_id, nextSegment);

    const newBadges = await checkBadgesForUser(request.user_id, true);

    setTimeout(async () => {
      try {
        await checkUserQuests(request.user_id);
      } catch (error) {
        console.error("Erreur lors de la v√©rification des qu√™tes:", error);
      }
    }, 0);

    setTimeout(async () => {
      try {
        const monthlyReward = await checkAndGrantMonthlyReward(request.user_id);
        if (monthlyReward) {
          console.log("R√©compense mensuelle obtenue :", monthlyReward);
        }
      } catch (error) {
        console.error("Erreur lors de la v√©rification des r√©compenses mensuelles:", error);
      }
    }, 0);

    // Get updated progress after validation
    const updatedProgress = await getBookReadingProgress(request.user_id, request.book_id);
    console.debug("[validateReading] New progress", updatedProgress);

    // Success toast only at the end when everything worked
    toast.success("Segment valid√© avec succ√®s");
    
    return {
      message: "Segment valid√© avec succ√®s",
      current_page: newCurrentPage,
      already_validated: false,
      next_segment_question: nextQuestion?.question ?? null,
      newBadges: newBadges.length > 0 ? newBadges : undefined
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Erreur inconnue";
    console.error('Error validating reading:', error);
    throw new Error(errorMessage);
  }
};
